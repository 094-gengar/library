{
	"cpp-base": {
	"prefix": "cppbase",
	"body": [
	"#if !__INCLUDE_LEVEL__",
	"#include __FILE__",
	"",
	"using namespace std;",
	"using namespace m9;",
	"",
	"int main()",
	"{",
	"\t$0",
	"}",
	"",
	"#else",
	"",
	"#include <cstdint>",
	"#include <cassert>",
	"#include <cmath>",
	"#include <unistd.h>",
	"#include <string>",
	"#include <array>",
	"#include <vector>",
	"#include <set>",
	"",
	"#define MY_FASTIO_VER2",
	"//#define IS_OUTPUT_ONLY",
	"",
	"namespace m9 {",
	"\tstruct fastin",
	"\t{",
	"\t\tstd::array<signed char, 1048576> _buf;",
	"\t\tssize_t n_w, n_r;",
	"\t#ifdef IS_OUTPUT_ONLY",
	"\t\tfastin() {}",
	"\t#else",
	"\t\tfastin() { _do_read(); }",
	"\t#endif",
	"\t\tlong long rd_ll() noexcept",
	"\t\t{",
	"\t\t\tlong long ret = 0, sgn = 1;",
	"\t\t\tsigned char ch = _current_char();",
	"\t\t\twhile(ch == ' ' || ch == '\\n')ch = _next_char();",
	"\t\t\tif(ch == '-') sgn *= -1, ch = _next_char();",
	"\t\t\tfor(; '0' <= ch && ch <= '9'; ch = _next_char())",
	"\t\t\t{",
	"\t\t\t\tret = (ret * 10) + ch - '0';",
	"\t\t\t}",
	"\t\t\treturn sgn * ret;",
	"\t\t}",
	"\t\tdouble rd_dbl() noexcept",
	"\t\t{",
	"\t\t\tdouble ret{}, sgn = 1;",
	"\t\t\tsigned char ch = _current_char();",
	"\t\t\twhile(ch == ' ' or ch == '\\n')ch = _next_char();",
	"\t\t\tif(ch == '-')sgn *= -1, ch = _next_char();",
	"\t\t\tbool foundDot = false;",
	"\t\t\tdouble mul = 1;",
	"\t\t\tfor(; ('0' <= ch && ch <= '9') or ch == '.'; ch = _next_char())",
	"\t\t\t{",
	"\t\t\t\tif(ch == '.') { foundDot = true; continue; }",
	"\t\t\t\tif(foundDot) { ret = ret + (ch - '0') / (mul *= 10); }",
	"\t\t\t\telse { ret = (ret * 10) + ch - '0'; }",
	"\t\t\t}",
	"\t\t\treturn sgn * ret;",
	"\t\t}",
	"\t\tint rd_int() noexcept",
	"\t\t{",
	"\t\t\tlong long _result = rd_ll();",
	"\t\t\tassert(-2147483648ll <= _result && _result <= 2147483647ll);",
	"\t\t\treturn static_cast<int>(_result);",
	"\t\t}",
	"\t\tstd::string rd_str() noexcept",
	"\t\t{",
	"\t\t\tstd::string _res{};",
	"\t\t\tsigned char ch = _current_char();",
	"\t\t\twhile(ch == ' ' || ch == '\\n')ch = _next_char();",
	"\t\t\tfor(; ch != -1 && ch != '\\n' && ch != ' '; ch = _next_char())",
	"\t\t\t{",
	"\t\t\t\t_res += std::string(1, ch);",
	"\t\t\t}",
	"\t\t\treturn _res;",
	"\t\t}",
	"\t\tchar rd_chr() noexcept",
	"\t\t{",
	"\t\t\tsigned char ch = _current_char();",
	"\t\t\twhile(ch == ' ' || ch == '\\n')ch = _next_char();",
	"\t\t\t_next_char();",
	"\t\t\treturn ch;",
	"\t\t}",
	"\tprivate:",
	"\t\tvoid _do_read() noexcept",
	"\t\t{",
	"\t\t\tssize_t r = read(0, &_buf[0], _buf.size());",
	"\t\t\tassert(r >= 0);",
	"\t\t\tn_w = r, n_r = 0;",
	"\t\t}",
	"\t\tinline signed char _next_char() noexcept",
	"\t\t{",
	"\t\t\tif(++n_r == n_w)_do_read();",
	"\t\t\treturn _current_char();",
	"\t\t}",
	"\t\tinline signed char _current_char() noexcept",
	"\t\t{",
	"\t\t\treturn (n_r == n_w ? -1 : _buf[n_r]);",
	"\t\t}",
	"\t} fi;",
	"",
	"\tstruct fastout",
	"\t{",
	"\t\tunsigned _wt_double_digit = 15;",
	"\t\tinline void wt_bool(bool x) noexcept { putchar_unlocked(x ? '1' : '0'); }",
	"\t\tinline void wt_ll(long long x) noexcept",
	"\t\t{",
	"\t\t\tstd::array<signed char, 32> _buf;",
	"\t\t\tssize_t _siz = 0;",
	"\t\t\tif(x < 0)",
	"\t\t\t{",
	"\t\t\t\tx *= -1;",
	"\t\t\t\tputchar_unlocked('-');",
	"\t\t\t}",
	"\t\t\tif(x == 0)putchar_unlocked('0');",
	"\t\t\twhile(x > 0)",
	"\t\t\t{",
	"\t\t\t\t_buf[_siz++] = x % 10 + '0';",
	"\t\t\t\tx /= 10;",
	"\t\t\t}",
	"\t\t\twhile(_siz--)putchar_unlocked(_buf[_siz]);",
	"\t\t}",
	"\t\tinline void wt_int(int x) noexcept { wt_ll(static_cast<long long>(x)); }",
	"\t\tinline void wt_ull(unsigned long long x) noexcept",
	"\t\t{",
	"\t\t\tstd::array<signed char, 32> _buf;",
	"\t\t\tssize_t _siz = 0;",
	"\t\t\tif(x == 0)putchar_unlocked('0');",
	"\t\t\twhile(x > 0)",
	"\t\t\t{",
	"\t\t\t\t_buf[_siz++] = x % 10 + '0';",
	"\t\t\t\tx /= 10;",
	"\t\t\t}",
	"\t\t\twhile(_siz--)putchar_unlocked(_buf[_siz]);",
	"\t\t}",
	"\t\tinline void wt_chr(char x) noexcept { putchar_unlocked(x); }",
	"\t\tinline void wt_str(std::string x) noexcept",
	"\t\t{",
	"\t\t\tssize_t _siz = static_cast<ssize_t>(x.length());",
	"\t\t\tfor(ssize_t i = 0; i < _siz; i++)putchar_unlocked(x[i]);",
	"\t\t}",
	"\t\tinline void wt_dbl(double x) noexcept",
	"\t\t{",
	"\t\t\tint k, r = 0;",
	"\t\t\tdouble v = 1;",
	"\t\t\tif(x < 0)",
	"\t\t\t{",
	"\t\t\t\tx *= -1;",
	"\t\t\t\tputchar_unlocked('-');",
	"\t\t\t}",
	"\t\t\tx += 0.5 * pow(0.1, _wt_double_digit);",
	"\t\t\twhile(x >= 10 * v)v *= 10, r++;",
	"\t\t\twhile(r-- >= 0)",
	"\t\t\t{",
	"\t\t\t\tk = floor(x / v);",
	"\t\t\t\tif(k >= 10)k = 9;",
	"\t\t\t\tif(k <= -1)k = 0;",
	"\t\t\t\tx -= k * v;",
	"\t\t\t\tv *= 0.1;",
	"\t\t\t\tputchar_unlocked(k + '0');",
	"\t\t\t}",
	"\t\t\tif(_wt_double_digit > 0)",
	"\t\t\t{",
	"\t\t\t\tputchar_unlocked('.');",
	"\t\t\t\tv = 1;",
	"\t\t\t\tfor(ssize_t _ = 0; _ < _wt_double_digit; _++)",
	"\t\t\t\t{",
	"\t\t\t\t\tv *= 0.1;",
	"\t\t\t\t\tk = floor(x / v);",
	"\t\t\t\t\tif(k >= 10)k = 9;",
	"\t\t\t\t\tif(k <= -1)k = 0;",
	"\t\t\t\t\tx -= k * v;",
	"\t\t\t\t\tputchar_unlocked(k + '0');",
	"\t\t\t\t}",
	"\t\t\t}",
	"\t\t}",
	"\t} fo;",
	"",
	"\tinline void set_digit(unsigned d) { fo._wt_double_digit = d; }",
	"\tinline void scan(int& x) noexcept { x = fi.rd_int(); }",
	"\tinline void scan(long& x) noexcept { x = (sizeof(long) == 32 ? fi.rd_int() : fi.rd_ll()); }",
	"\tinline void scan(long long& x) noexcept { x = fi.rd_ll(); }",
	"\tinline void scan(unsigned& x) noexcept",
	"\t{",
	"\t\tint a = fi.rd_int();",
	"\t\tassert(a >= 0);",
	"\t\tx = a;",
	"\t}",
	"\tinline void scan(unsigned long& x) noexcept",
	"\t{",
	"\t\tlong a;",
	"\t\tscan(a);",
	"\t\tassert(a >= 0l);",
	"\t\tx = a;",
	"\t}",
	"\tinline void scan(unsigned long long& x) noexcept",
	"\t{",
	"\t\tlong long a = fi.rd_ll();",
	"\t\tassert(a >= 0ll);",
	"\t\tx = a;",
	"\t}",
	"\t// inline void scan(double& x) noexcept { x = static_cast<double>(fi.rd_ll()); }",
	"\tinline void scan(double& x) noexcept { x = fi.rd_dbl(); }",
	"\tinline void scan(char& x) noexcept { x = fi.rd_chr(); }",
	"\tinline void scan(std::string& x) noexcept { x = fi.rd_str(); }",
	"\ttemplate <class T, class U>",
	"\tinline void scan(std::pair<T, U>& x) { scan(x.first); scan(x.second); }",
	"\ttemplate <class T>",
	"\tinline void scan(std::vector<T>& x) { for(auto& e : x)scan(e); }",
	"\tvoid IN() {}",
	"\ttemplate <class Car, class... Cdr>",
	"\tvoid IN(Car&& car, Cdr &&...cdr)",
	"\t{",
	"\t\tscan(car);",
	"\t\tIN(std::forward<Cdr>(cdr)...);",
	"\t}",
	"",
	"\tinline void wt_any(const bool& x) noexcept { fo.wt_bool(x); }",
	"\tinline void wt_any(const int& x) noexcept { fo.wt_int(x); }",
	"\tinline void wt_any(const long& x) noexcept { fo.wt_ll(static_cast<long>(x)); }",
	"\tinline void wt_any(const long long& x) noexcept { fo.wt_ll(x); }",
	"\tinline void wt_any(const unsigned& x) noexcept { fo.wt_ull(static_cast<unsigned long long>(x)); }",
	"\tinline void wt_any(const unsigned long& x) noexcept { fo.wt_ull(static_cast<unsigned long long>(x)); }",
	"\tinline void wt_any(const unsigned long long& x) noexcept { fo.wt_ull(x); }",
	"\tinline void wt_any(const double& x) noexcept { fo.wt_dbl(x); }",
	"\tinline void wt_any(const long double& x) noexcept { fo.wt_dbl(x); }",
	"\tinline void wt_any(const char& x) noexcept { fo.wt_chr(x); }",
	"\tinline void wt_any(const char x[]) noexcept",
	"\t{",
	"\t\tsize_t _siz = 0;",
	"\t\twhile(x[_siz] != '\\0')fo.wt_chr(x[_siz++]);",
	"\t}",
	"\tinline void wt_any(const std::string& x) noexcept { fo.wt_str(x); }",
	"\ttemplate <class T, class U>",
	"\tinline void wt_any(const std::pair<T, U>& x)",
	"\t{",
	"\t\twt_any(x.first);",
	"\t\twt_any(' ');",
	"\t\twt_any(x.second);",
	"\t}",
	"\ttemplate <class T>",
	"\tinline void wt_any(const std::vector<T>& x)",
	"\t{",
	"\t\tssize_t _siz = x.size();",
	"\t\tfor(ssize_t i = 0; i < _siz - 1; i++)wt_any(x[i]), wt_any(' ');",
	"\t\tif(not x.empty())wt_any(x.back());",
	"\t}",
	"\ttemplate <class T>",
	"\tinline void wt_any(const std::set<T>& x)",
	"\t{",
	"\t\tfor(const auto& e : x)wt_any(e), wt_any(' ');",
	"\t}",
	"",
	"\tint print() { wt_any('\\n'); return 0; }",
	"\ttemplate <class T>",
	"\tint print(const T& t)",
	"\t{",
	"\t\twt_any(t);",
	"\t\twt_any('\\n');",
	"\t\treturn 0;",
	"\t}",
	"\ttemplate <class T>",
	"\tint print(const std::vector<std::vector<T>>& x)",
	"\t{",
	"\t\tfor(const auto& v : x)print(v);",
	"\t\treturn 0;",
	"\t}",
	"\ttemplate <class Car, class... Cdr>",
	"\tint print(const Car& car, const Cdr &...cdr)",
	"\t{",
	"\t\twt_any(car);",
	"\t\twt_any(' ');",
	"\t\tprint(cdr...);",
	"\t\treturn 0;",
	"\t}",
	"\ttemplate <class T>",
	"\tint wt(const T& t)",
	"\t{",
	"\t\twt_any(t);",
	"\t\treturn 0;",
	"\t}",
	"\ttemplate <class Car, class... Cdr>",
	"\tint wt(const Car& car, const Cdr &...cdr)",
	"\t{",
	"\t\twt_any(car);",
	"\t\twt(cdr...);",
	"\t\treturn 0;",
	"\t}",
	"\tvoid yn(bool fl = true) { print(fl ? \"Yes\" : \"No\"); }",
	"\ttemplate <class... T>",
	"\tvoid drop(const T&... x) { print(x...); exit(0); }",
	"\tvoid dyn(bool fl = true) { print(fl ? \"Yes\" : \"No\"); exit(0); }",
	"} // namespace m9",
	"",
	"#define INT(...)  int __VA_ARGS__; IN(__VA_ARGS__)",
	"#define LL(...)  long long __VA_ARGS__; IN(__VA_ARGS__)",
	"#define ULL(...)  unsigned long long __VA_ARGS__; IN(__VA_ARGS__)",
	"#define STR(...)  std::string __VA_ARGS__; IN(__VA_ARGS__)",
	"#define CHR(...)  char __VA_ARGS__; IN(__VA_ARGS__)",
	"#define DBL(...)  double __VA_ARGS__; IN(__VA_ARGS__)",
	"",
	"namespace m9 {",
	"\tusing ll = long long;",
	"\tusing ull = unsigned long long;",
	"\tusing pii = std::pair<int, int>;",
	"\tusing pll = std::pair<ll, ll>;",
	"} // namespace m9",
	"",
	"#define VEC(a, type, n) std::vector<type> (a)(n); IN(a)",
	"#define VVEC(a, type, h, w) std::vector<std::vector<type>> (a)(h, std::vector<type>(w)); IN(a)",
	"",
	"#define VI(a, n) VEC(a, int, n)",
	"#define VVI(a, h, w) VVEC(a, int, h, w)",
	"#define VPII(a, n) VEC(a, pii, n)",
	"#define VVPII(a, h, w) VVEC(a, pii, h, w)",
	"#define VLL(a, n) VEC(a, ll, n)",
	"#define VVLL(a, h, w) VVEC(a, ll, h, w)",
	"#define VPLL(a, n) VEC(a, pll, n)",
	"#define VVPLL(a, h, w) VVEC(a, pll, h, w)",
	"#define VULL(a, n) VEC(a, ull, n)",
	"#define VVULL(a, h, w) VVEC(a, ull, h, w)",
	"#define VC(a, n) VEC(a, char, n)",
	"#define VVC(a, h, w) VVEC(a, char, h, w)",
	"#define VD(a, n) VEC(a, double, n)",
	"#define VVD(a, h, w) VVEC(a, double, h, w)",
	"#define VS(a, n) VEC(a, std::string, n)",
	"",
	"#include <iostream>",
	"",
	"namespace m9 {",
	"#define MY_MODINT",
	"\ttemplate <long long Mod> struct modInt {",
	"\t\tlong long x;",
	"\t\tconstexpr modInt() noexcept : x() {}",
	"\t\ttemplate <class T>",
	"\t\tconstexpr modInt(T v = 0) noexcept : x(v% Mod) { if(x < 0)x += Mod; }",
	"\t\tconstexpr long long val() const noexcept { return x; }",
	"\t\tconstexpr modInt operator-() const noexcept { return x ? Mod - x : 0; }",
	"\t\tconstexpr modInt operator+(const modInt& r) const noexcept { return modInt(*this) += r; }",
	"\t\tconstexpr modInt operator-(const modInt& r) const noexcept { return modInt(*this) -= r; }",
	"\t\tconstexpr modInt operator*(const modInt& r) const noexcept { return modInt(*this) *= r; }",
	"\t\tconstexpr modInt operator/(const modInt& r) const noexcept { return modInt(*this) /= r; }",
	"\t\tconstexpr modInt& operator+=(const modInt& r) noexcept { x += r.x; if(x >= Mod)x -= Mod; return *this; }",
	"\t\tconstexpr modInt& operator-=(const modInt& r) noexcept { x -= r.x; if(x < 0)x += Mod; return *this; }",
	"\t\tconstexpr modInt& operator*=(const modInt& r) noexcept { x = x * r.x % Mod; return *this; }",
	"\t\tconstexpr modInt& operator/=(const modInt& r) noexcept { x = x * r.inv().val() % Mod; return *this; }",
	"\t\tconstexpr modInt powm(long long n) noexcept",
	"\t\t{",
	"\t\t\tif(n < 0)return powm(-n).inv();",
	"\t\t\tmodInt x = *this, r = 1;",
	"\t\t\tfor(; n; x *= x, n >>= 1)if(n & 1)r *= x;",
	"\t\t\treturn r;",
	"\t\t}",
	"\t\tconstexpr modInt inv() const noexcept",
	"\t\t{",
	"\t\t\tlong long a = x, b = Mod, u = 1, v = 0;",
	"\t\t\twhile(b)",
	"\t\t\t{",
	"\t\t\t\tlong long t = a / b;",
	"\t\t\t\ta -= t * b;",
	"\t\t\t\tstd::swap(a, b);",
	"\t\t\t\tu -= t * v;",
	"\t\t\t\tstd::swap(u, v);",
	"\t\t\t}",
	"\t\t\treturn modInt(u);",
	"\t\t}",
	"\t\tconstexpr modInt comb(long long a) noexcept",
	"\t\t{",
	"\t\t\tmodInt n = *this, s = 1;",
	"\t\t\tfor(int i = 0; i < a; i++)s *= (n - modInt(i));",
	"\t\t\tmodInt m = 1;",
	"\t\t\tfor(int i = 1; i <= a; i++)m *= modInt(i);",
	"\t\t\treturn s * m.powm(Mod - 2);",
	"\t\t}",
	"\t\tconstexpr bool operator==(const modInt& r) { return this->x == r.x; }",
	"\t\tconstexpr bool operator!=(const modInt& r) { return this->x != r.x; }",
	"\t\tfriend std::ostream& operator<<(std::ostream& os, const modInt<Mod>& a) { return os << a.x; }",
	"\t\tfriend std::istream& operator>>(std::istream& is, modInt<Mod>& a)",
	"\t\t{",
	"\t\t\tlong long v;",
	"\t\t\tis >> v;",
	"\t\t\ta = modInt<Mod>(v);",
	"\t\t\treturn is;",
	"\t\t}",
	"\t};",
	"",
	"\ttemplate <long long M> inline void wt_any(const modInt<M>& x) { wt_any(x.val()); }",
	"",
	"\tusing mint1000000007 = modInt<1000000007>;",
	"\tusing mint998244353 = modInt<998244353>;",
	"\tmint1000000007 operator\"\" _m107(unsigned long long x) { return mint1000000007(x); }",
	"\tmint998244353 operator\"\" _m998(unsigned long long x) { return mint998244353(x); }",
	"",
	"\tstruct cent_t {",
	"\tprivate:",
	"\t\t__int128_t N;",
	"\tpublic:",
	"\t\ttemplate <class T>",
	"\t\tconstexpr cent_t(T n) : N(static_cast<__int128_t>(n)) {}",
	"\t\tfriend std::ostream& operator<<(std::ostream& os, const cent_t& a)",
	"\t\t\t{ if(a.N > INT64_MAX)return os << \"too big integer\"; else return os << static_cast<long long>(a.N); }",
	"\t\tfriend std::istream& operator>>(std::istream& is, cent_t& a)",
	"\t\t\t{ long long tmp{}; is >> tmp; a.N = static_cast<__int128_t>(tmp); return is; }",
	"\t\tconstexpr __int128_t val() const noexcept { return N; }",
	"\t\tconstexpr cent_t operator-() const noexcept { return -N; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator+(const INTEGER& x) const noexcept { return N + x.N; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator-(const INTEGER& x) const noexcept { return N - x.N; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator*(const INTEGER& x) const noexcept { return N * x.N; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator/(const INTEGER& x) const noexcept { return N / x.N; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator<<(const INTEGER& x) const noexcept { return N << x; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator>>(const INTEGER& x) const noexcept { return N >> x; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator+=(const INTEGER& x) noexcept { N += x.N; return *this; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator-=(const INTEGER& x) noexcept { N -= x.N; return *this; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator*=(const INTEGER& x) noexcept { N *= x.N; return *this; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator/=(const INTEGER& x) noexcept { N /= x.N; return *this; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator<<=(const INTEGER& x) const noexcept { N <<= x.N; return *this; }",
	"\t\ttemplate <class INTEGER> constexpr cent_t operator>>=(const INTEGER& x) const noexcept { N >>= x.N; return *this; }",
	"\t\tconstexpr cent_t operator++() noexcept { N += 1; return *this; }",
	"\t\tconstexpr cent_t operator--() noexcept { N -= 1; return *this; }",
	"\t\ttemplate <class INTEGER> constexpr bool operator==(const INTEGER& x) { return this->N == x.N; }",
	"\t\ttemplate <class INTEGER> constexpr bool operator!=(const INTEGER& x) { return this->N != x.N; }",
	"\t\ttemplate <class INTEGER> constexpr bool operator<(const INTEGER& x) { return this->N < x.N; }",
	"\t\ttemplate <class INTEGER> constexpr bool operator>(const INTEGER& x) { return this->N > x.N; }",
	"\t\ttemplate <class INTEGER> constexpr bool operator<=(const INTEGER& x) { return this->N <= x.N; }",
	"\t\ttemplate <class INTEGER> constexpr bool operator>=(const INTEGER& x) { return this->N >= x.N; }",
	"\t};",
	"",
	"\tusing i8 = signed char;",
	"\tusing u8 = unsigned char;",
	"\tusing i32 = signed int;",
	"\tusing u32 = unsigned int;",
	"\tusing i64 = signed long long;",
	"\tusing u64 = unsigned long long;",
	"",
	"\ti8 operator\"\" _i8(unsigned long long x) { return static_cast<i8>(x); }",
	"\tu8 operator\"\" _u8(unsigned long long x) { return static_cast<u8>(x); }",
	"\ti32 operator\"\" _i32(unsigned long long x) { return static_cast<i32>(x); }",
	"\tu32 operator\"\" _u32(unsigned long long x) { return static_cast<u32>(x); }",
	"\ti64 operator\"\" _i64(unsigned long long x) { return static_cast<i64>(x); }",
	"\tu64 operator\"\" _u64(unsigned long long x) { return static_cast<u64>(x); }",
	"\tcent_t operator\"\" _i128(unsigned long long x) { return cent_t(x); }",
	"",
	"\tusing f32 = float;",
	"\tusing f64 = double;",
	"\tdouble operator\"\" _f32(unsigned long long x) { return static_cast<f32>(x); }",
	"\tdouble operator\"\" _f64(unsigned long long x) { return static_cast<f64>(x); }",
	"} // namespace m9",
	"",
	"#include <cstdlib>",
	"#include <cmath>",
	"#include <climits>",
	"#include <cfloat>",
	"#include <map>",
	"// #include <utility>",
	"#include <set>",
	"#include <iostream>",
	"#include <memory>",
	"#include <string>",
	"#include <vector>",
	"#include <algorithm>",
	"#include <functional>",
	"#include <sstream>",
	"#include <deque>",
	"#include <complex>",
	"#include <stack>",
	"#include <queue>",
	"#include <cstdio>",
	"#include <cctype>",
	"#include <cstdint>",
	"#include <cstring>",
	"#include <ctime>",
	"#include <chrono>",
	"// #include <bit>",
	"#include <iterator>",
	"#include <bitset>",
	"#include <numeric>",
	"#include <list>",
	"#include <iomanip>",
	"#include <cassert>",
	"#include <array>",
	"#include <tuple>",
	"#include <initializer_list>",
	"#include <unordered_set>",
	"#include <unordered_map>",
	"#include <forward_list>",
	"#include <random>",
	"#include <regex>",
	"//#define INCLUDE_BOOST",
	"#ifdef INCLUDE_BOOST",
	"#if __has_include(<boost/range/irange.hpp>)",
	"#include <boost/range/irange.hpp>",
	"#include <boost/algorithm/string/split.hpp>",
	"#include <boost/algorithm/string/join.hpp>",
	"#include <boost/algorithm/string/replace.hpp>",
	"#include <boost/algorithm/string/classification.hpp>",
	"#endif",
	"#endif",
	"//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,fma,abm,mmx,avx,avx2\")",
	"#pragma GCC optimize(\"O3\")",
	"#pragma GCC optimize(\"unroll-loops\")",
	"#define all(x) std::begin(x), std::end(x)",
	"#define Sort(x) sort(all(x))",
	"#define rSort(x) sort(all(x)); reverse(all(x))",
	"#define UNIQUE(v) v.erase(unique(all(v)), v.end())",
	"#define uniq(v) sort(all(v)); UNIQUE(v)",
	"#define l_b(c, x) distance(begin(c), lower_bound(all(c), (x)))",
	"#define u_b(c, x) distance(begin(c), upper_bound(all(c), (x)))",
	"#define fi first",
	"#define se second",
	"#define m_p make_pair",
	"#define m_t make_tuple",
	"#define pb push_back",
	"#define eb emplace_back",
	"#define cauto const auto&",
	"#define _rep_overload(_1, _2, _3, _4, name, ...) name",
	"#define _rep1(i, n) _rep2(i, 0, n)",
	"#define _rep2(i, a, b) for(ll i = (a); i < (b); i++)",
	"#define _rep3(i, a, b, c) for(ll i = (a); i < (b); i += c)",
	"#define rep(...) _rep_overload(__VA_ARGS__, _rep3, _rep2, _rep1)(__VA_ARGS__)",
	"#define myceil(a, b) ((a) + ((b) - 1)) / (b)",
	"#define continue_with(...) ({__VA_ARGS__; continue;})",
	"#define break_with(...) ({__VA_ARGS__; break;})",
	"",
	"namespace m9 {",
	"\tusing ll = long long;",
	"\tusing ull = unsigned long long;",
	"\tusing pii = std::pair<int, int>;",
	"\tusing pll = std::pair<ll, ll>;",
	"} // namespace m9",
	"",
	"namespace m9 {",
	"\ttemplate <class T> using V = std::vector<T>;",
	"\tusing vb = V<std::int8_t>;",
	"\tusing vi = V<int>;",
	"\tusing vu = V<unsigned>;",
	"\tusing vll = V<ll>;",
	"\tusing vull = V<ull>;",
	"\tusing vd = V<double>;",
	"\tusing vc = V<char>;",
	"\tusing vs = V<std::string>;",
	"\tusing vpii = V<pii>;",
	"\tusing vpll = V<pll>;",
	"",
	"\tusing vvb = V<vb>;",
	"\tusing vvi = V<vi>;",
	"\tusing vvu = V<vu>;",
	"\tusing vvll = V<vll>;",
	"\tusing vvull = V<vull>;",
	"\tusing vvd = V<vd>;",
	"\tusing vvc = V<vc>;",
	"\tusing vvs = V<vs>;",
	"\tusing vvpii = V<vpii>;",
	"\tusing vvpll = V<vpll>;",
	"",
	"\ttemplate <class T>",
	"\tinline bool chmin(T& a, const T& b) { if(b < a) { a = b; return true; } return false; }",
	"\ttemplate <class T>",
	"\tinline bool chmax(T& a, const T& b) { if(a < b) { a = b; return true; } return false; }",
	"",
	"\tll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }",
	"\tll lcm(ll a, ll b) { return a / gcd(a, b) * b; }",
	"\tll fact(ll n, ll m) { ll f = n; for(ll i = n - 1; i >= 1; i--) { f *= i; if(m != -1)f %= m; } return f; }",
	"",
	"\tconstexpr ll inf = 0x1fffffffffffffff;",
	"\tconstexpr ll mod = 1000000007LL;",
	"\tconstexpr ll mod2 = 998244353LL;",
	"\tconstexpr double eps = 1e-8;",
	"\tconstexpr double pi = 3.141592653589793238462643383279;",
	"} // namespace m9",
	"",
	"namespace m9 {",
	"\tstruct sorted_operator {",
	"\t\ttemplate <class T> friend std::vector<T> operator>>(std::vector<T>a, sorted_operator)",
	"\t\t\t{ std::sort(std::begin(a), std::end(a)); return a; }",
	"\t\tfriend std::string operator>>(std::string a, sorted_operator)",
	"\t\t\t{ std::sort(std::begin(a), std::end(a)); return a; }",
	"\t} Sor;",
	"\tstruct reversed_operator {",
	"\t\ttemplate <class T> friend std::vector<T> operator>>(std::vector<T> a, reversed_operator)",
	"\t\t\t{ std::reverse(std::begin(a), std::end(a)); return a; }",
	"\t\tfriend std::string operator>>(std::string a, reversed_operator)",
	"\t\t\t{ std::reverse(std::begin(a), std::end(a)); return a; }",
	"\t} Rev;",
	"\tstruct unique_operator {",
	"\t\ttemplate <class T> friend std::vector<T> operator>>(std::vector<T> a, unique_operator)",
	"\t\t\t{ a.erase(unique(std::begin(a), std::end(a)), std::end(a)); return a; }",
	"\t\tfriend std::string operator>>(std::string a, unique_operator)",
	"\t\t\t{ a.erase(unique(std::begin(a), std::end(a)), std::end(a)); return a; }\t",
	"\t} Set;",
	"\ttemplate <class T>",
	"\tvoid INCVEC(std::vector<T>& a) { for(T& e : a)e++; }",
	"\ttemplate <class T>",
	"\tvoid DECVEC(std::vector<T>& a) { for(T& e : a)e--; }",
	"\tstruct inc_operator {",
	"\t\ttemplate <class T> friend std::vector<T> operator>>(std::vector<T> a, inc_operator)",
	"\t\t\t{ INCVEC(a); return a; }",
	"\t} Inc;",
	"\tstruct dec_operator {",
	"\t\ttemplate <class T> friend std::vector<T> operator>>(std::vector<T> a, dec_operator)",
	"\t\t\t{ DECVEC(a); return a; }",
	"\t} Dec;",
	"\ttemplate <class T, class F>",
	"\tauto operator>> (std::vector<T> a, F f) -> std::vector<decltype(f(a.front()))>",
	"\t{",
	"\t\tstd::vector<decltype(f(a.front()))> res{};",
	"\t\tfor(const T& e : a)res.emplace_back(f(e));",
	"\t\treturn res;",
	"\t}",
	"} // namespace m9",
	"",
	"// debug",
	"",
	"#ifdef ONLINE_JUDGE",
	"#define dbg(...) void(0)",
	"#else",
	"#define dbg(...) _debug(#__VA_ARGS__, __VA_ARGS__)",
	"#endif",
	"",
	"namespace m9 {",
	"\ttemplate <class Car, class... Cdr>",
	"\tvoid _debug(const char* s, Car&& car, Cdr&&... cdr)",
	"\t{",
	"\t\tconstexpr const char* open_br = sizeof...(cdr) == 0 ? \"\" : \"(\";",
	"\t\tconstexpr const char* close_br = sizeof...(cdr) == 0 ? \"\" : \")\";",
	"#ifdef MY_FASTIO_VER2",
	"\t\twt_any(open_br); wt_any(s); wt_any(close_br);",
	"\t\twt_any(\" : \");",
	"\t\twt_any(open_br); wt_any(std::forward<Car>(car));",
	"\t\t((wt_any(\", \"), wt_any(std::forward<Cdr>(cdr))), ...);",
	"\t\twt_any(close_br); wt_any(\"\\n\");",
	"#else",
	"\t\tstd::cerr << open_br << s << close_br << \" : \" << open_br << std::forward<Car>(car);",
	"\t\t((std::cerr << \", \" << std::forward<Cdr>(cdr)), ...);",
	"\t\tstd::cerr << close_br << \"\\n\";",
	"#endif",
	"\t}",
	"} // namespace m9",
	"",
	"#endif"
	],
	"description": "cpp-base"
	},
	
	
	"snip-Graph": {
	"prefix": "snipGraph",
	"body": [
	"#include <cassert>",
	"#include <iostream>",
	"#include <vector>",
	"#include <queue>",
	"#include <algorithm>",
	"#include <limits>",
	"",
	"namespace m9 {",
	"template<class T> struct Graph {",
	"\ttemplate<class _T> inline bool chmin(_T& a, const _T& b)",
	"\t{",
	"\t\tif(b < a) { a = b; return true; }",
	"\t\telse return false;",
	"\t}",
	"\tint SIZ;",
	"\t// bool isOffset;",
	"\t// bool isDirected;",
	"\tstd::vector<std::vector<T>> G;",
	"\tGraph() = default;",
	"\tGraph(int n) : SIZ(n) {}",
	"\t// Graph(int n, bool offset, bool directed) : SIZ(n), isOffset(offset), isDirected(directed), G(n) {}",
	"",
	"\tvoid init(std::vector<std::vector<T>> g) { SIZ = g.size(); G = g; }",
	"\tstd::vector<T> bfs(T s, T t = -1)",
	"\t{",
	"\t\tassert(0 <= s and s < SIZ);",
	"\t\tassert((t == -1) or (0 <= s or s < SIZ));",
	"\t\tstd::vector<T> dist(SIZ, std::numeric_limits<T>::max() / 2);",
	"\t\tstd::vector<std::int8_t> vis(SIZ, false);",
	"\t\tdist[s] = 0;",
	"\t\tstd::queue<T> q{};",
	"\t\tq.emplace(s);",
	"\t\twhile(!q.empty())",
	"\t\t{",
	"\t\t\tT cur = q.front(); q.pop();",
	"\t\t\tfor(const auto& e : G[cur])if(chmin(dist[e], dist[cur] + 1))q.emplace(e);",
	"\t\t}",
	"\t\treturn (t == -1 ? dist : std::vector<T>{dist[t]});",
	"\t}",
	"};",
	"",
	"// #include <utility>",
	"",
	"template<class T> struct weightedGraph {",
	"\tusing PTT = std::pair<T, T>;",
	"\ttemplate<class _T> inline bool chmin(_T& a, const _T& b)",
	"\t{",
	"\t\tif(b < a) { a = b; return true; }",
	"\t\telse return false;",
	"\t}",
	"\tint SIZ;",
	"\t// bool isOffset;",
	"\t// bool isDirected;",
	"\tstd::vector<std::vector<PTT>> G;",
	"\tweightedGraph() = default;",
	"\tweightedGraph(int n) : SIZ(n) {}",
	"\t// weightedGraph(int n, bool os, bool drc) : SIZ(n), isOffset(os), isDirected(drc), G(n) {}",
	"",
	"\tvoid init(std::vector<std::vector<PTT>> g) { SIZ = g.size(); G = g; }",
	"\tstd::vector<T> bfs(T s, T t = -1)",
	"\t{",
	"\t\tassert(0 <= s and s < SIZ);",
	"\t\tassert((t == -1) or (0 <= s or s < SIZ));",
	"\t\tstd::vector<T> dist(SIZ, std::numeric_limits<T>::max() / 2);",
	"\t\tstd::vector<std::int8_t> vis(SIZ, false);",
	"\t\tdist[s] = 0;",
	"\t\tstd::queue<PTT> q{};",
	"\t\tq.emplace(0, s);",
	"\t\twhile(!q.empty())",
	"\t\t{",
	"\t\t\tconst auto [curCst, curE]= q.front(); q.pop();",
	"\t\t\tif(curCst > dist[curE])continue;",
	"\t\t\tfor(const auto&[cst, e] : G[curE])if(chmin(dist[e], dist[curE] + cst))q.emplace(dist[e], e);",
	"\t\t}",
	"\t\treturn (t == -1 ? dist : std::vector<T>{dist[t]});",
	"\t}",
	"\tstd::vector<T> dijk(T s, T t = -1)",
	"\t{",
	"\t\tassert(0 <= s and s < SIZ);",
	"\t\tassert((t == -1) or (0 <= s or s < SIZ));",
	"\t\tstd::vector<T> dist(SIZ, std::numeric_limits<T>::max() / 2);",
	"\t\tstd::vector<std::int8_t> vis(SIZ, false);",
	"\t\tdist[s] = 0;",
	"\t\tstd::priority_queue<PTT, std::vector<PTT>, std::greater<>> pq{};",
	"\t\tpq.emplace(0, s);",
	"\t\twhile(!pq.empty())",
	"\t\t{",
	"\t\t\tconst auto [curCst, curE]= pq.top(); pq.pop();",
	"\t\t\tif(curCst > dist[curE])continue;",
	"\t\t\tfor(const auto&[cst, e] : G[curE])if(chmin(dist[e], dist[curE] + cst))pq.emplace(dist[e], e);",
	"\t\t}",
	"\t\treturn (t == -1 ? dist : std::vector<T>{dist[t]});",
	"\t}",
	"};",
	"} // namespace m9"
	],
	"description": "snip-Graph"
	},
	
	
	"snip-LCA": {
	"prefix": "snipLCA",
	"body": [
	"#include <vector>",
	"",
	"// Euler Tourもしてるやつ → https://atcoder.jp/contests/abc294/submissions/39948286",
	"",
	"namespace m9 {",
	"struct LCA {",
	"\tstd::vector<std::vector<int>> par;",
	"\tstd::vector<int> dis;",
	"\tLCA(const std::vector<std::vector<int>>& g, int root = 0) { init(g, root); }",
	"\tvoid init(const std::vector<std::vector<int>>& g, int root = 0)",
	"\t{",
	"\t\tint v = g.size(), k = 1;",
	"\t\tfor(; 1 << k < v; k++) {}",
	"\t\tpar.assign(k, std::vector<int>(v, -1));",
	"\t\tdis.assign(v, -1);",
	"\t\tdfs(g, root, -1, 0);",
	"\t\tfor(int i = 0; i < k - 1; i++)for(int j = 0; j < v; j++)",
	"\t\t{",
	"\t\t\tif(par[i][j] < 0)par[i + 1][j] = -1;",
	"\t\t\telse par[i + 1][j] = par[i][par[i][j]];",
	"\t\t}",
	"\t}",
	"\tvoid dfs(const std::vector<std::vector<int>>& g, int v, int p, int d)",
	"\t{",
	"\t\tpar[0][v] = p;",
	"\t\tdis[v] = d;",
	"\t\tfor(int e : g[v])if(e != p)dfs(g, e, v, d + 1);",
	"\t}",
	"\tint run(int u, int v)",
	"\t{",
	"\t\tif(dis[u] < dis[v])std::swap(u, v);",
	"\t\tint k = par.size();",
	"\t\tfor(int i = 0; i < k; i++)if(dis[u] - dis[v] >> i & 1)u = par[i][u];",
	"\t\tif(u == v)return u;",
	"\t\tfor(int i = k - 1; i >= 0; i--)if(par[i][u] != par[i][v])",
	"\t\t{",
	"\t\t\tu = par[i][u];",
	"\t\t\tv = par[i][v];",
	"\t\t}",
	"\t\treturn par[0][u];",
	"\t}",
	"\tint distance(int u, int v) { return dis[u] + dis[v] - dis[run(u, v)] * 2; }",
	"\tbool isOnPath(int u, int v, int a) { return distance(u, a) + distance(a, v) == distance(u, v); }",
	"};",
	"} // namespace m9",
	""
	],
	"description": "snip-LCA"
	},
	
	"snip-Argsort": {
	"prefix": "snipArgsort",
	"body": [
	"// #include <utility>",
	"#include <iostream>",
	"",
	"namespace m9 {",
	"template<class T> bool arg_cmp(const std::pair<T, T>& p, const std::pair<T, T>& q)",
	"{",
	"\tauto area = [](const std::pair<T, T>& a) -> int {",
	"\t\tconst auto&[x, y] = a;",
	"\t\tif(y < 0)return -1;",
	"\t\telse if(y == 0 and 0 <= x)return 0;",
	"\t\telse return 1;",
	"\t};",
	"\tconst int ap = area(p);",
	"\tconst int aq = area(q);",
	"\tif(ap != aq)return ap < aq;",
	"\telse",
	"\t{",
	"\t\tconst auto& [px, py] = p;",
	"\t\tconst auto& [qx, qy] = q;",
	"\t\treturn (0 < (px * qy - py * qx));",
	"\t}",
	"}",
	"} // namespace m9"
	],
	"description": "snip-Argsort"
	},
	
	"snip-CRT": {
	"prefix": "snipCRT",
	"body": [
	"#include <vector>",
	"#include <cassert>",
	"",
	"namespace m9 {",
	"using ll = long long;",
	"",
	"namespace m9_crt {",
	"template<class T> T ext_gcd(T a, T b, T &x, T &y)",
	"{",
	"    if(b == 0)",
	"\t{",
	"        x = 1, y = 0;",
	"        return a;",
	"    }",
	"    T d = ext_gcd(b, a % b, y, x);",
	"    y -= a / b * x;",
	"    return d;",
	"}",
	"",
	"} // m9_crt",
	"",
	"template<class T>",
	"std::pair<T, T> ChnRemThm(std::vector<T>& r, std::vector<T>& m)",
	"{",
	"\tassert(r.size() == m.size());",
	"\tint n = r.size();",
	"\tll ret_r{0}, ret_m{1};",
	"\tfor(int i{0}; i < n; i++)",
	"\t{",
	"\t\tassert(m[i] >= 1);",
	"\t\tll p{}, q{};",
	"\t\tll g = m9_crt::ext_gcd(ret_m, m[i], p, q);",
	"\t\tif((r[i] - ret_r) % g != 0) { return std::make_pair((T)0, (T)0); }",
	"\t\tll tmp = (r[i] - ret_r) / g * p % (m[i] / g);",
	"\t\tret_r += ret_m * tmp;",
	"\t\tret_m *= m[i] / g;",
	"\t\tret_r = (ret_r % ret_m + ret_m) % ret_m;",
	"\t}",
	"",
	"\treturn std::make_pair(ret_r, ret_m);",
	"}",
	"",
	"} // namespace m9"
	],
	"description": "snip-CRT"
	},
	
	"snip-Combination": {
	"prefix": "snipCombination",
	"body": [
	"#include <cassert>",
	"#include <vector>",
	"",
	"namespace m9 {",
	"template<class T> struct combination {",
	"\tusing ll = long long;",
	"\tll N;",
	"\tstd::vector<T> fct;",
	"\tcombination(ll n) : N(n)",
	"\t{",
	"\t\tfct.resize(N + 1);",
	"\t\tfct[0] = 1;",
	"\t\tfor(ll i{1}; i <= N; i++)fct[i] = fct[i - 1] * i;",
	"\t}",
	"\tT nPr(ll n, ll r) { return n < 0 || r < 0 || n < r ? (T)(0) : fct[n] / fct[n - r]; }",
	"\tT nCr(ll n, ll r) { return n < 0 || r < 0 || n < r ? (T)(0) : nPr(n, r) / fct[r]; }",
	"\tT nHr(ll n, ll r) {return n < 0 || r + n - 1 < 0 || n < r + n - 1 ? (T)(0) : nCr(r + n - 1, r); }",
	"};",
	"} // namespace m9"
	],
	"description": "snip-Combination"
	},
	
	"snip-DivisorList": {
	"prefix": "snipDivisorList",
	"body": [
	"#include <vector>",
	"#include <algorithm>",
	"",
	"namespace m9 {",
	"template<class T> std::vector<T> divisorList(const T& N)",
	"{",
	"\tstd::vector<T> result{};",
	"\tfor(T i{1}; i * i <= N; i++)",
	"\t{",
	"\t\tif(N % i == 0)",
	"\t\t{",
	"\t\t\tresult.emplace_back(i);",
	"\t\t\tif(i * i != N)result.emplace_back(N / i);",
	"\t\t}",
	"\t}",
	"\tstd::sort(std::begin(result), std::end(result));",
	"\treturn result;",
	"}",
	"} // namespace m9"
	],
	"description": "snip-DivisorList"
	},
	
	"snip-PrimeFactor": {
	"prefix": "snipPrimeFactor",
	"body": [
	"#include <vector>",
	"",
	"namespace m9 {",
	"template<class T> std::vector<std::pair<T, T>> prime_factor(T n)",
	"{",
	"\tstd::vector<std::pair<T, T>> ret;",
	"\tfor(T i{2}; i * i <= n; i++)",
	"\t{",
	"\t\tif(n % i != 0)continue;",
	"\t\tT tmp = 0;",
	"\t\twhile(n % i == 0)",
	"\t\t{",
	"\t\t\ttmp++;",
	"\t\t\tn /= i;",
	"\t\t}",
	"\t\tret.push_back(std::make_pair(i, tmp));",
	"\t}",
	"\tif(n != 1)",
	"\t\tret.push_back(std::make_pair(n, 1));",
	"\treturn ret;",
	"}",
	"} // namespace m9"
	],
	"description": "snip-PrimeFactor"
	},
	
	"snip-PrimeFactorPollard": {
	"prefix": "snipPrimeFactorPollard",
	"body": [
	"#include <vector>",
	"#include <numeric>",
	"#include <algorithm>",
	"",
	"namespace m9 {",
	"using ll = long long;",
	"",
	"namespace m9_pfp {",
	"template<class T> T PM(T X, T N, T M)",
	"{",
	"\tT ret{1};",
	"\twhile(N > 0)",
	"\t{",
	"\t\tif(N & 1) { (ret *= X) %= M; }",
	"\t\t(X *= X) %= M;",
	"\t\tN >>= 1;",
	"\t}",
	"\treturn ret;",
	"}",
	"",
	"bool IP(ll N)",
	"{",
	"\tif(N <= 1) { return false; }",
	"\tif(N == 2 || N == 3) { return true; }",
	"\tif(N % 2 == 0) { return false; }",
	"\tauto A = std::vector<ll>{2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
	"\tll s{}, d{N - 1};",
	"\twhile(d % 2 == 0) { s++; d >>= 1; }",
	"\tfor(const auto& a : A)",
	"\t{",
	"\t\tif(a % N == 0) { return true; }",
	"\t\tll t, x = PM<__int128_t>(a, d, N);",
	"\t\tif(x != 1)",
	"\t\t{",
	"\t\t\tfor(t = 0; t < s; t++)",
	"\t\t\t{",
	"\t\t\t\tif(x == N - 1) { break; }",
	"\t\t\t\tx = (__int128_t)(x) * x % N;",
	"\t\t\t}",
	"\t\t\tif(t == s) { return false; }",
	"\t\t}",
	"\t}",
	"\treturn true;",
	"}",
	"",
	"} // namespace m9_pfp",
	"",
	"ll pollard(ll N)",
	"{",
	"\tif(N % 2 == 0)return 2;",
	"\tif(m9_pfp::IP(N)) { return N; }",
	"\tauto f = [&](ll x) -> ll {",
	"\t\treturn ((__int128_t(x) * x + 1) % N);",
	"\t};",
	"\tll step{};",
	"\twhile(true)",
	"\t{",
	"\t\tstep++;",
	"\t\tll x = step;",
	"\t\tll y = f(x);",
	"\t\twhile(true)",
	"\t\t{",
	"\t\t\tll p = std::gcd(y - x + N, N);",
	"\t\t\tif(p == 0 || p == N) { break; }",
	"\t\t\tif(p != 1) { return p; }",
	"\t\t\tx = f(x);",
	"\t\t\ty = f(f(y));",
	"\t\t}",
	"\t}",
	"}",
	"",
	"std::vector<ll> primeFactPollard(ll N)",
	"{",
	"\tif(N == 1) { return std::vector<ll>{}; }",
	"\tll p = pollard(N);",
	"\tif(p == N) { return std::vector<ll>{p}; }",
	"\tstd::vector<ll> L = primeFactPollard(p), R = primeFactPollard(N / p);",
	"\tL.insert(std::end(L), std::begin(R), std::end(R));",
	"\tstd::sort(std::begin(L), std::end(L));",
	"\treturn L;",
	"}",
	"}"
	],
	"description": "snip-PrimeFactorPollard"
	},
	
	"snip-gridtoInt": {
	"prefix": "snipgridtoInt",
	"body": [
	"// #include <utility>",
	"#include <iostream>",
	"",
	"namespace m9 {",
	"\ttemplate<class T> auto GridtoT(const T width, const T x, const T y) -> T {",
	"\t\treturn x * width + y;",
	"\t}",
	"\ttemplate<class T> auto GridtoT(const T width, const std::pair<T, T> p) -> T {",
	"\t\treturn p.first * width + p.second;",
	"\t}",
	"\ttemplate<class T> auto TtoGrid(const T width, const T N) -> std::pair<T, T> {",
	"\t\treturn std::make_pair(N / width, N % width);",
	"\t}",
	"} // namespace m9"
	],
	"description": "snip-gridtoInt"
	},
	
	"snip-BinaryIndexedTree": {
	"prefix": "snipBinaryIndexedTree",
	"body": [
	"#include <cassert>",
	"#include <vector>",
	"",
	"namespace m9 {",
	"template<class T> class BIT {",
	"\tint SIZ;",
	"\tstd::vector<T> tree;",
	"public:",
	"\tBIT(int n = 0, T x = 0) : SIZ(n), tree(n, x) {}",
	"\tT sum(int i)",
	"\t{",
	"\t\tassert(0 <= i and i <= SIZ);",
	"\t\tT result{0};",
	"\t\tfor(; i > 0; i -= (i & -i))result += tree[i - 1];",
	"\t\treturn result;",
	"\t}",
	"\tT sum(int l, int r) { return sum(r) - sum(l); }",
	"\tvoid add(int i, T a) { assert(0 <= i and i < SIZ); for(i++; i <= SIZ; i += (i & -i))tree[i - 1] += a; }",
	"\tint lowerBound(T k)",
	"\t{",
	"\t\tif(k <= 0)return 0;",
	"\t\tint result{0}, i{1};",
	"\t\tfor(; (i << 1) <= SIZ; )i <<= 1;",
	"\t\tfor(; i; i >>= 1)if(result + i <= SIZ and tree[result + i] < k)k -= tree[result += i];",
	"\t\treturn result;",
	"\t}",
	"};",
	"} // namespace m9"
	],
	"description": "snip-BinaryIndexedTree"
	},
	
	"snip-CompressVec": {
	"prefix": "snipCompressVec",
	"body": [
	"#include <map>",
	"",
	"namespace m9 {",
	"template<class T> struct compress {",
	"private:",
	"\tint SIZ;",
	"public:",
	"\tstd::vector<T> C;",
	"\tcompress(std::vector<T> a)",
	"\t{",
	"\t\tSIZ = a.size();",
	"\t\tC = a;",
	"\t\tstd::map<T, T> mp{};",
	"\t\tfor(int i{}; i < SIZ; i++)mp[C[i]] = -1;",
	"\t\tint c{};",
	"\t\tfor(auto&[key, value] : mp)value = c++;",
	"\t\tfor(int i{}; i < SIZ; i++)C[i] = mp[C[i]];",
	"\t}",
	"\tvoid init(std::vector<T> a)",
	"\t{",
	"\t\tSIZ = a.size();",
	"\t\tC = a;",
	"\t\tstd::map<T, T> mp{};",
	"\t\tfor(int i{}; i < SIZ; i++)mp[C[i]] = -1;",
	"\t\tint c{};",
	"\t\tfor(auto&[key, value] : mp)value = c++;",
	"\t\tfor(int i{}; i < SIZ; i++)C[i] = mp[C[i]];",
	"\t}",
	"\tT operator[](int idx) { assert(0 <= idx and idx < SIZ); return C[idx]; }",
	"};",
	"} // namespace m9"
	],
	"description": "snip-CompressVec"
	},
	
	"snip-Cumsum": {
	"prefix": "snipCumsum",
	"body": [
	"#include <cassert>",
	"",
	"namespace m9 {",
	"template<class T> struct cumsum {",
	"private:",
	"\tint SIZ;",
	"public:",
	"\tstd::vector<T> S;",
	"\tcumsum(std::vector<T> a)",
	"\t{",
	"\t\tSIZ = a.size();",
	"\t\tS.assign(SIZ + 1, 0);",
	"\t\tfor(int i{}; i < SIZ; i++)S[i + 1] = S[i] + a[i];",
	"\t}",
	"\tvoid init(std::vector<T> a)",
	"\t{",
	"\t\tSIZ = a.size();",
	"\t\tS.assign(SIZ + 1, 0);",
	"\t\tfor(int i{}; i < SIZ; i++)S[i + 1] = S[i] + a[i];",
	"\t}",
	"\tT operator[](int idx) { assert(0 <= idx and idx <= SIZ); return S[idx]; }",
	"};",
	"} // namespace m9"
	],
	"description": "snip-Cumsum"
	},
	
	"snip-RollingHash": {
	"prefix": "snipRollingHash",
	"body": [
	"#include <vector>",
	"#include <cassert>",
	"#include <cmath>",
	"",
	"namespace m9 {",
	"",
	"using ll = long long;",
	"",
	"template<class T> struct RollingHash {",
	"private:",
	"\tint N;",
	"\tconst ll MOD = (1ll << 61) - 1;",
	"\tll base;",
	"\tstd::vector<ll> Hs{}, Pw{};",
	"\tll mul(ll x, ll y) const { return (__int128_t)(x) * y % MOD; }",
	"public:",
	"\tRollingHash() = default;",
	"\tRollingHash(const T& s, ll base = -1) : N(s.size()) {",
	"\t\tif(base == -1){ base = base = 1e9 + 7; }",
	"\t\tHs.assign(N + 1, 0); Pw.assign(N + 1, 1);",
	"\t\tfor(int i{}; i < N; i++)",
	"\t\t{",
	"\t\t\tHs[i + 1] = (mul(Hs[i], base) + s[i]) % MOD;",
	"\t\t\tPw[i + 1] = (mul(Pw[i], base)) % MOD;",
	"\t\t}",
	"\t}",
	"",
	"\tll get(const int l, const int r) const",
	"\t{",
	"\t\tassert(l <= r and 0 <= l and r <= N);",
	"\t\treturn (Hs[r] - mul(Hs[l], Pw[r - l]) % MOD + MOD) % MOD;",
	"\t}",
	"",
	"\tll getAll() const { return get(0, N);}",
	"",
	"\tint get_LongestCommonPrefix(const int a, const int b) const",
	"\t{",
	"\t\tassert(a >= 0 and b >= 0 and a < N and b < N);",
	"\t\tint ok{0}, ng{std::min(N - a, N - b)};",
	"\t\twhile(abs(ok - ng) > 1)",
	"\t\t{",
	"\t\t\tint mid = (ok + ng) / 2;",
	"\t\t\t(get(a, a + mid) != get(b, b + mid) ? ng : ok) = mid;",
	"\t\t}",
	"\t\treturn ok;",
	"\t}",
	"};",
	"}",
	""
	],
	"description": "snip-RollingHash"
	},
	
	"snip-SegmentTree": {
	"prefix": "snipSegmentTree",
	"body": [
	"#include <cassert>",
	"#include <vector>",
	"",
	"namespace m9 {",
	"template<class M> class segmentTree {",
	"\tusing T = typename M::valueType;",
	"\tstd::vector<T> seg;",
	"\tint SIZ;",
	"public:",
	"\tsegmentTree(int n) { for(SIZ = 1; SIZ < n; )SIZ <<= 1; seg.assign(2 * SIZ, M::id);}",
	"\tvoid update(int k, const T& x) { assert(0 <= k and k < SIZ); for(seg[k += SIZ] = x; k>>= 1; )seg[k] = M::op(seg[2 * k], seg[2 * k + 1]); }",
	"\tvoid set(int k, const T& x) { assert(0 <= k and k < SIZ); seg[k + SIZ] = x; }",
	"\tT operator[](const int& k) const { assert(0 <= k and k < SIZ); return seg[k + SIZ]; }",
	"\tvoid build() { for(int k = SIZ - 1; k > 0; k--)seg[k] = M::op(seg[2 * k], seg[2 * k + 1]); }",
	"\tT query(int a, int b)",
	"\t{",
	"\t\tassert(0 <= a and a <= b and b <= SIZ);",
	"\t\tauto L = M::id;",
	"\t\tauto R = M::id;",
	"\t\tfor(a += SIZ, b += SIZ; a < b; a >>= 1, b >>= 1)",
	"\t\t{",
	"\t\t\tif(a & 1)L = M::op(L, seg[a++]);",
	"\t\t\tif(b & 1)R = M::op(seg[--b], R);",
	"\t\t}",
	"\t\treturn M::op(L, R);",
	"\t}",
	"\ttemplate<class C> int findSubtree(int a, const C& check, T& mono, bool type)",
	"\t{",
	"\t\tfor(; a < SIZ; )",
	"\t\t{",
	"\t\t\tauto next = M::op(seg[2 * a + type], mono);",
	"\t\t\tif(check(next))a = 2 * a + type;",
	"\t\t\telse mono = next, a = 2 * a + !type;",
	"\t\t}",
	"\t\treturn (a - SIZ);",
	"\t}",
	"\ttemplate<class C> int findFirst(int a, const C& check)",
	"\t{",
	"\t\tassert(0 <= a and a <= SIZ);",
	"\t\tauto L = M::id;",
	"\t\tif(a <= 0)return (check(M::op(L, seg[1])) ? findSubtree(1, check, L, false) : -1);",
	"\t\tint b = SIZ;",
	"\t\tfor(a += SIZ, b += SIZ; a < b; a >>= 1, b >>= 1)",
	"\t\t{",
	"\t\t\tif(a & 1)",
	"\t\t\t{",
	"\t\t\t\tauto next = M::op(L, seg[a]);",
	"\t\t\t\tif(check(next))return findSubtree(a, check, L, false);",
	"\t\t\t\tL = next;",
	"\t\t\t\ta++;",
	"\t\t\t}",
	"\t\t}",
	"\t\treturn -1;",
	"\t}",
	"\ttemplate<class C> int findLast(int b, const C& check)",
	"\t{",
	"\t\tassert(0 <= b and b <= SIZ);",
	"\t\tauto R = M::id;",
	"\t\tif(b >= SIZ)return (check(M::op(seg[1], R)) ? findSubtree(1, check, R, true) : -1);",
	"\t\tint a = SIZ;",
	"\t\tfor(b += SIZ; a < b; a >>= 1, b >>= 1)",
	"\t\t{",
	"\t\t\tif(b & 1)",
	"\t\t\t{",
	"\t\t\t\tauto next = M::op(seg[--b], R);",
	"\t\t\t\tif(check(next))return findSubtree(b, check, R, true);",
	"\t\t\t\tR = next;",
	"\t\t\t}",
	"\t\t}",
	"\t\treturn -1;",
	"\t}",
	"};",
	"",
	"struct RSumQ {",
	"\tusing valueType = int;",
	"\tstatic int op(int a, int b) { return a + b; }",
	"\tstatic inline int id{0};",
	"};",
	"struct RSumQLL {",
	"\tusing valueType = long long;",
	"\tstatic long long op(long long a, long long b) { return a + b; }",
	"\tstatic inline long long id{0};",
	"};",
	"struct RMaxQ {",
	"\tusing valueType = int;",
	"\tstatic int op(int a, int b) { return std::max(a, b); }",
	"\tstatic inline int id{-(1 << 29)};",
	"};",
	"struct RMaxQLL {",
	"\tusing valueType = long long;",
	"\tstatic long long op(long long a, long long b) { return std::max(a, b); }",
	"\tstatic inline long long id{-(1ll << 60)};",
	"};",
	"struct RminQ {",
	"\tusing valueType = int;",
	"\tstatic int op(int a, int b) { return std::min(a, b); }",
	"\tstatic inline int id{1 << 29};",
	"};",
	"struct RminQLL {",
	"\tusing valueType = long long;",
	"\tstatic long long op(long long a, long long b) { return std::min(a, b); }",
	"\tstatic inline long long id{1ll << 60};",
	"};",
	"} // namespace m9"
	],
	"description": "snip-SegmentTree"
	},
	
	"snip-Trie": {
	"prefix": "snipTrie",
	"body": [
	"// つかいかた：",
	"// m9::Trie<26, 'a'> trie;",
	"// trie.insert(\"atcoder\");",
	"// trie.search(\"atcoder\")   -> true",
	"// trie.search(\"at\")        -> false",
	"// trie.search_prefix(\"at\") -> true",
	"",
	"#include <string>",
	"#include <algorithm>",
	"#include <vector>",
	"",
	"namespace m9 {",
	"template<int BAND_SIZE> struct TrieSub {",
	"\tint16_t C{};",
	"\tint common;",
	"\tstd::vector<int> child;",
	"\tstd::vector<int> accept{};",
	"\tTrieSub(int16_t C) : C(C), common(0)",
	"\t{",
	"\t\tchild.assign(BAND_SIZE, -1);",
	"\t}",
	"};",
	"",
	"template<int BAND_SIZE, int16_t BASE_CHAR> struct Trie {",
	"\tusing Node = TrieSub<BAND_SIZE>;",
	"\tstd::vector<Node> Nodes{};",
	"\tint root{0};",
	"",
	"\tTrie() { Nodes.emplace_back(Node(root)); }",
	"\tvoid insert(const std::string& word, int word_id)",
	"\t{",
	"\t\tint len = word.length();",
	"\t\tint node_id{0};",
	"\t\tfor(int i{0}; i < len; i++)",
	"\t\t{",
	"\t\t\tint16_t c = (int16_t)(word[i]) - BASE_CHAR;",
	"\t\t\tint& next_id = Nodes[node_id].child[c];",
	"\t\t\tif(next_id == -1)",
	"\t\t\t{",
	"\t\t\t\tnext_id = (int)(Nodes.size());",
	"\t\t\t\tNodes.emplace_back(Node(c));",
	"\t\t\t}",
	"\t\t\tNodes[node_id].common++;",
	"\t\t\tnode_id = next_id;",
	"\t\t}",
	"\t\tNodes[node_id].common++;",
	"\t\tNodes[node_id].accept.emplace_back(word_id);",
	"\t}",
	"",
	"\tvoid insert(const std::string& word)",
	"\t{",
	"\t\tinsert(word, Nodes[0].common);",
	"\t}",
	"",
	"\tbool search(const std::string& word, bool prefix = false)",
	"\t{",
	"\t\tint len = word.length();",
	"\t\tint node_id{0};",
	"\t\tfor(int i{0}; i < len; i++)",
	"\t\t{",
	"\t\t\tint16_t C = (int16_t)(word[i]) - BASE_CHAR;",
	"\t\t\tint& next_id = Nodes[node_id].child[C];",
	"\t\t\tif(next_id == -1) { return false; }",
	"\t\t\tnode_id = next_id;",
	"\t\t}",
	"\t\treturn (prefix || (Nodes[node_id].accept.size() > 0));",
	"\t}",
	"",
	"\tbool search_prefix(const std::string& prefix)",
	"\t{",
	"\t\treturn search(prefix, true);",
	"\t}",
	"",
	"\tint count() const { return (Nodes.front().common); }",
	"\tlong long size() const { return Nodes.size(); }",
	"};",
	"} // namespace m9",
	""
	],
	"description": "snip-Trie"
	},
	
	"snip-UndoUnionFind": {
	"prefix": "snipUndoUnionFind",
	"body": [
	"// つかいかた：",
	"// https://atcoder.jp/contests/abc328/submissions/47510970",
	"#include <vector>",
	"#include <stack>",
	"#include <numeric>",
	"",
	"struct UndoUnionFind {",
	"\tstd::vector<int> par, sz;",
	"\tstd::stack<std::pair<int, std::pair<int, int>>> hist;",
	"\tUndoUnionFind(int N) : par(N), sz(N, 1) { std::iota(std::begin(par), std::end(par), 0); }",
	"\tint root(int x) const { return (par[x] == x) ? x : root(par[x]); }",
	"\tbool merge(int a, int b)",
	"\t{",
	"\t\ta = root(a); b = root(b);",
	"\t\tif(sz[a] < sz[b])std::swap(a, b);",
	"\t\thist.emplace(b, std::make_pair(par[b], sz[a]));",
	"\t\treturn a != b ? par[b] = a, sz[a] += sz[b], true : false;",
	"\t}",
	"\tvoid undo()",
	"\t{",
	"\t\tsz[par[hist.top().first]] = hist.top().second.second;",
	"\t\tpar[hist.top().first] = hist.top().second.first;",
	"\t\thist.pop();",
	"\t}",
	"\tint size(int x) const { return sz[root(x)]; }",
	"\tbool same(int a, int b) const { return root(a) == root(b); }",
	"};"
	],
	"description": "snip-UndoUnionFind"
	},
	
	"snip-UnionFind": {
	"prefix": "snipUnionFind",
	"body": [
	"#include <cassert>",
	"#include <vector>",
	"#include <algorithm>",
	"",
	"namespace m9 {",
	"class UnionFind {",
	"\tint SIZ;",
	"\tstd::vector<int> a;",
	"public:",
	"\tUnionFind(int n) : SIZ(n), a(n) { for(int i{}; i < SIZ; i++)a[i] = -1; }",
	"\tint root(int x) { assert(x < SIZ); return (a[x] < 0 ? x : (a[x] = root(a[x]))); }",
	"\tbool same(int x, int y) { assert(x < SIZ); assert(y < SIZ); return root(x) == root(y); }",
	"\tvoid merge(int x, int y)",
	"\t{",
	"\t\tassert(x < SIZ);",
	"\t\tassert(y < SIZ);",
	"\t\tx = root(x), y = root(y);",
	"\t\tif(x == y)return;",
	"\t\tif(a[x] > a[y])std::swap(x, y);",
	"\t\ta[x] += a[y], a[y] = x;",
	"\t}",
	"\tint size(int x) { assert(x < SIZ); return -a[root(x)]; }",
	"\tstd::vector<std::vector<int>> groups()",
	"\t{",
	"\t\tstd::vector<int> rootBuf(SIZ), groupSize(SIZ);",
	"\t\tfor(int i{}; i < SIZ; i++)groupSize[rootBuf[i] = root(i)]++;",
	"\t\tstd::vector<std::vector<int>> result(SIZ);",
	"\t\tfor(int i{}; i < SIZ; i++)result[i].reserve(groupSize[i]);",
	"\t\tfor(int i{}; i < SIZ; i++)result[rootBuf[i]].emplace_back(i);",
	"\t\tresult.erase( \\",
	"\t\t\tremove_if(std::begin(result),",
	"\t\t\t\tstd::end(result),",
	"\t\t\t\t[&](const std::vector<int>& v) -> bool { return v.empty(); }),",
	"\t\t\tstd::end(result));",
	"\t\treturn result;",
	"\t}",
	"};",
	"",
	"using uni = UnionFind;",
	"} // namespace m9"
	],
	"description": "snip-UnionFind"
	},
	
	"snip-WeightedUnionFind": {
	"prefix": "snipWeightedUnionFind",
	"body": [
	"// つかいかた：",
	"// https://atcoder.jp/contests/abc328/submissions/47511359",
	"#include <vector>",
	"#include <numeric>",
	"",
	"template <class S> struct WeightedUnionFind {",
	"\tstd::vector<int> par, sz;",
	"\tstd::vector<S> pot;",
	"\tWeightedUnionFind(int N = 0) : par(N), sz(N, 1), pot(N) {",
	"\t\tstd::iota(begin(par), end(par), 0);",
	"\t}",
	"\tint root(int x)",
	"\t{",
	"\t\tif(par[x] != x)",
	"\t\t{",
	"\t\t\tint r = root(par[x]);",
	"\t\t\tpot[x] = pot[x] + pot[par[x]];",
	"\t\t\tpar[x] = r;",
	"\t\t}",
	"\t\treturn par[x];",
	"\t}",
	"\tbool merge(int a, int b, S rel_diff)",
	"\t{",
	"\t\t// マージできるときはtrue、出来ないときはfalseを返す",
	"\t\trel_diff = rel_diff + weight(a) + (-weight(b));",
	"\t\ta = root(a);",
	"\t\tb = root(b);",
	"\t\tif(a == b)return rel_diff == 0;",
	"\t\tif(sz[a] < sz[b])std::swap(a, b), rel_diff *= -1;",
	"\t\tpar[b] = a;",
	"\t\tsz[a] += sz[b];",
	"\t\tpot[b] = rel_diff;",
	"\t\treturn true;",
	"\t}",
	"\tS weight(int x) { root(x); return pot[x]; }",
	"\tS diff(int a, int b) { return weight(b) + (-weight(a)); }",
	"\tint size(int x) { return sz[root(x)]; }",
	"\tbool same(int a, int b) { return root(a) == root(b); }",
	"};"
	],
	"description": "snip-WeightedUnionFind"
	}
	}